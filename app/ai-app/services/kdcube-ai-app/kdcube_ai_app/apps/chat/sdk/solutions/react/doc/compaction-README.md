# Context Compaction (v2)

Compaction is the **hard ceiling** protection for context length. It inserts a
`conv.range.summary` block and drops older blocks from the **visible** stream.
It is separate from TTL pruning (which hides blocks with replacement text).

---

## When Compaction Runs
Compaction runs in two situations:

1) **Normal render path (pre‑send)**
   - `Timeline.render(...)` estimates total tokens.
   - If `system + blocks > 0.9 * max_tokens`, it compacts immediately.

2) **Retry after context‑limit error**
   - If the decision call fails with a context‑limit error, `retry_with_compaction`
     forces compaction and retries.

In both cases, compaction is executed inside `Timeline.render()` via
`sanitize_context_blocks(...)`.

---

## Render Pipeline Order (Important)
During `render()`:

1. **TTL pruning** (`apply_session_cache_ttl_pruning`) runs first.
2. **Compaction** (`sanitize_context_blocks`) runs next if needed or forced.
3. The visible stream is sliced **after the latest summary**.
4. Hidden blocks are replaced with their `replacement_text`.
5. Cache points are recomputed for the visible stream.

This ordering ensures compaction works on the already‑pruned timeline and that
cache points remain valid after compaction.

---

## Exact Cut‑Point Rules (Authoritative)
Cut points are chosen by `_find_compaction_cut_point` using these exact rules:

### 1) Candidate cut points
A block is a **cut‑point candidate** if `_is_cut_point_block(block)` returns true:

- **Reject**: `react.tool.result`, `conv.range.summary`
- **Accept**: `user.prompt`, `assistant.completion`, `react.tool.call`, `turn.header`
- **Accept**: any block with `author` in `{user, assistant}`
- **Accept**: any block with `author` present and **not** in `{system, tool}`

This prevents cutting inside tool results and prefers user/assistant or tool call boundaries.

### 2) Message blocks for token accounting
Token accounting uses `_is_message_block`:

- `react.tool.result` counts as a message block
- Otherwise, same as `_is_cut_point_block`

This ensures tool results contribute to the “recent tokens” budget, but they
are **not valid cut‑points**.

### 3) Cut index selection
- Walk backward accumulating tokens from message blocks until
  `accumulated >= keep_recent_tokens`.
- Choose the **first candidate cut point at or after** that index.
- Then **backtrack** until the cut is on a message boundary or just after a
  summary block.

### 4) Turn boundary and split turns
A **turn start block** is:
- `turn.header` or `user.prompt`, or
- any block with `author == user`

If the cut does **not** land on a turn start, it is a split‑turn cut and the
prefix of that turn is summarized separately under:

`"Turn Context (split turn)"`

The cut block itself remains in the retained window.

---

## What Compaction Produces
Compaction inserts a **summary block**:

- `type = conv.range.summary`
- `path = su:<turn_id>.conv.range.summary`
- `meta.compaction_digest` describes compacted artifacts
- `meta.covered_turn_ids` lists turns compacted into the summary
- `meta.split_turn_id` exists if compaction cut a turn in half

**Summary content** is generated by:
- `summarize_context_blocks_progressive(..., max_tokens=800)`
- plus `summarize_turn_prefix_progressive(..., max_tokens=400)` if the cut splits a turn

---

## What Exactly Gets Summarized
Compaction summarizes **everything between the last summary (if any) and the cut point**.
The retained window starts **at the cut point**.

If the cut falls **inside a turn**, only the **prefix** of that turn is summarized
(and included under “Turn Context (split turn)”). The cut block itself stays visible.

---

## Persistence Rule
After compaction, the timeline is **persisted from the last summary onward**:

- In‑memory for the current turn: pre‑summary blocks still exist but are no
  longer visible.
- On persistence / next turn load: only blocks **from the latest summary onward**
  are kept.

This keeps the prefix small while allowing the summary to represent old turns.

---

## Cache Points After Compaction
Cache points are **recomputed** after compaction and hidden‑replacement.
The rules are the same as normal rendering:

1. **Previous‑turn cache point** (last block before current turn, if available)
2. **Pre‑tail cache point** (last block of round `N‑4`, based on
   `cache_point_offset_rounds=4`)
3. **Tail cache point** (last block in visible stream)

This ensures caching stays valid even after summary insertion.

---

## Reference Diagram (with cache points)
The cache points are placed on **specific blocks**, not “between” turns:

1) **Prev‑turn cache point** → the *last block* immediately before the current turn header.  
2) **Pre‑tail cache point** → the *last block* of round `N‑4` from the tail (if enough rounds).  
3) **Tail cache point** → the *last block* in the visible stream.

### Example (enough rounds for pre‑tail)
Current turn is **TURN E**; tail = last block of TURN E; offset = 4 rounds.

```
Before:
  [TURN A] [TURN B] [TURN C] [TURN D] [TURN E]
         ^ pre‑tail cache (end of TURN A, N‑4)
                                    ^ prev‑turn cache (end of TURN D)
                                             ^ tail cache (end of TURN E)
```

After compaction (summary covers A..C; visible D..E):

```
After compaction (in memory):
  [SUMMARY(A..C)] [TURN D] [TURN E]
                         ^ prev‑turn cache (end of TURN D)
                                  ^ tail cache (end of TURN E)
  (pre‑tail cache is omitted if visible rounds < min_rounds)
```

If the cut lands inside TURN C:

```
Before:
  [TURN A] [TURN B] [TURN C (prefix)] [TURN C (tail)] [TURN D] [TURN E]

After compaction (in memory):
  [SUMMARY(A..B + C‑prefix)] [TURN C (tail)] [TURN D] [TURN E]
```

---

## Compaction Digest
`meta.compaction_digest` includes structured summaries of compacted blocks:
- produced artifacts (path, mime, visibility, sources_used)
- tool outputs (by tool type)
- memsearch hits and paths
- hidden blocks and replacement text

It is used to recover context if later needed via `react.read`.

---

## Hooks
If provided in `RuntimeCtx`:

- `on_before_compaction({before_tokens})`
- `on_after_compaction({before_tokens, after_tokens, compacted_tokens})`

---

## Test Coverage
Tests live in `test_timeline_compaction.py` and cover:
- summary insertion
- split‑turn handling
- no compaction under limit
- compaction after existing summary
- digest includes hidden blocks
- tool boundary preservation
- cache points after render
